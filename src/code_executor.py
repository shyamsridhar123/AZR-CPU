"""
Code Executor for the Absolute Zero Reasoner system.
Provides safe execution environment for task validation and solution verification.
"""

import sys
import ast
import time
import psutil
import signal
import subprocess
import tempfile
import os
from typing import Dict, Any, Optional, Union
from contextlib import contextmanager
import threading
import queue
import traceback
import logging


class ExecutionTimeout(Exception):
    """Exception raised when code execution times out."""
    pass


class ExecutionError(Exception):
    """Exception raised when code execution fails."""
    pass


class MemoryLimitExceeded(Exception):
    """Exception raised when memory limit is exceeded."""
    pass


class CodeExecutor:
    """
    Safe code executor with timeout, memory limits, and sandboxing.
    Validates and executes Python code generated by the AZR system.
    """
    
    def __init__(self, config):
        self.config = config
        self.timeout = config.execution_timeout
        self.memory_limit_mb = config.max_memory_mb
        self.logger = logging.getLogger(__name__)
        
        # Restricted builtins for safer execution
        self.safe_builtins = {
            '__builtins__': {
                'abs': abs, 'all': all, 'any': any, 'bin': bin, 'bool': bool,
                'chr': chr, 'dict': dict, 'divmod': divmod, 'enumerate': enumerate,
                'filter': filter, 'float': float, 'format': format, 'frozenset': frozenset,
                'hasattr': hasattr, 'hash': hash, 'hex': hex, 'int': int, 'isinstance': isinstance,
                'issubclass': issubclass, 'iter': iter, 'len': len, 'list': list,
                'map': map, 'max': max, 'min': min, 'next': next, 'oct': oct,
                'ord': ord, 'pow': pow, 'range': range, 'repr': repr, 'reversed': reversed,
                'round': round, 'set': set, 'slice': slice, 'sorted': sorted,
                'str': str, 'sum': sum, 'tuple': tuple, 'type': type, 'zip': zip,
                'True': True, 'False': False, 'None': None,
                # Math operations
                'lambda': lambda: None  # Placeholder, actual lambdas will be parsed
            }
        }
        
        # Forbidden imports and functions
        self.forbidden_names = {
            'import', 'exec', 'eval', 'open', 'file', 'input', 'raw_input',
            'compile', 'reload', '__import__', 'exit', 'quit', 'help',
            'os', 'sys', 'subprocess', 'socket', 'urllib', 'requests'
        }
    
    def execute_safe(self, code: str, input_data: str = "") -> Dict[str, Any]:
        """
        Safely execute code with timeout and memory limits.
        
        Args:
            code: Python code to execute
            input_data: Input data for the code
            
        Returns:
            Dict containing success status, output, error message, and execution time
        """
        result = {
            'success': False,
            'output': None,
            'error': None,
            'execution_time': 0.0,
            'memory_used': 0.0
        }
        
        start_time = time.time()
        
        try:
            # Validate code syntax and safety
            if not self._validate_code_safety(code):
                result['error'] = "Code contains forbidden operations"
                return result
            
            # Parse and validate AST
            try:
                parsed_ast = ast.parse(code)
                if not self._validate_ast_safety(parsed_ast):
                    result['error'] = "Code contains unsafe AST nodes"
                    return result
            except SyntaxError as e:
                result['error'] = f"Syntax error: {str(e)}"
                return result
            
            # Execute with timeout and memory monitoring
            output = self._execute_with_limits(code, input_data)
            
            result['success'] = True
            result['output'] = output
            
        except ExecutionTimeout:
            result['error'] = f"Execution timed out after {self.timeout} seconds"
        except MemoryLimitExceeded:
            result['error'] = f"Memory limit exceeded ({self.memory_limit_mb} MB)"
        except Exception as e:
            result['error'] = f"Execution error: {str(e)}"
            self.logger.debug(f"Execution error details: {traceback.format_exc()}")
        
        result['execution_time'] = time.time() - start_time
        return result
    
    def _validate_code_safety(self, code: str) -> bool:
        """Validate that code doesn't contain forbidden operations."""
        # Check for forbidden names
        for forbidden in self.forbidden_names:
            if forbidden in code:
                return False
        
        # Check for dangerous patterns
        dangerous_patterns = [
            'exec(', 'eval(', '__import__', 'open(', 'file(',
            'subprocess', 'os.', 'sys.', 'socket.', 'urllib',
            'while True:', 'for i in range(999999'
        ]
        
        for pattern in dangerous_patterns:
            if pattern in code:
                return False
        
        return True
    
    def _validate_ast_safety(self, node: ast.AST) -> bool:
        """Validate AST for safety using whitelist approach."""
        allowed_nodes = {
            ast.Module, ast.Expression, ast.Interactive,
            # Literals
            ast.Constant, ast.Num, ast.Str, ast.Bytes, ast.NameConstant,
            ast.Ellipsis, ast.List, ast.Tuple, ast.Set, ast.Dict,
            # Variables
            ast.Name, ast.Load, ast.Store, ast.Del,
            # Expressions
            ast.Expr, ast.BinOp, ast.UnaryOp, ast.Lambda, ast.IfExp,
            ast.ListComp, ast.SetComp, ast.DictComp, ast.GeneratorExp,
            ast.Compare, ast.Call, ast.Attribute, ast.Subscript, ast.Slice,
            # Operators
            ast.Add, ast.Sub, ast.Mult, ast.Div, ast.Mod, ast.Pow,
            ast.LShift, ast.RShift, ast.BitOr, ast.BitXor, ast.BitAnd,
            ast.FloorDiv, ast.Invert, ast.Not, ast.UAdd, ast.USub,
            ast.Eq, ast.NotEq, ast.Lt, ast.LtE, ast.Gt, ast.GtE,
            ast.Is, ast.IsNot, ast.In, ast.NotIn, ast.And, ast.Or,
            # Control flow (limited)
            ast.If, ast.For, ast.While, ast.Break, ast.Continue,
            ast.Return, ast.Assign, ast.AugAssign,
            # Functions (limited)
            ast.FunctionDef, ast.arguments, ast.arg,
            # Comprehensions
            ast.comprehension,
        }
        
        for node in ast.walk(node):
            if type(node) not in allowed_nodes:
                self.logger.debug(f"Forbidden AST node: {type(node)}")
                return False
        
        return True
    
    def _execute_with_limits(self, code: str, input_data: str) -> Any:
        """Execute code with timeout and memory monitoring."""
        result_queue = queue.Queue()
        exception_queue = queue.Queue()
        
        def target():
            try:
                # Monitor memory usage
                process = psutil.Process()
                initial_memory = process.memory_info().rss / 1024 / 1024  # MB
                
                # Prepare execution environment
                local_vars = {}
                global_vars = self.safe_builtins.copy()
                
                # Handle input data
                if input_data:
                    try:
                        # Try to evaluate input as Python literal
                        input_value = ast.literal_eval(input_data)
                        local_vars['input_data'] = input_value
                    except (ValueError, SyntaxError):
                        # Treat as string if not a valid literal
                        local_vars['input_data'] = input_data
                
                # Execute the code
                if code.strip().startswith('lambda'):
                    # Handle lambda functions
                    func = eval(code, global_vars, local_vars)
                    if 'input_data' in local_vars:
                        if isinstance(local_vars['input_data'], (list, tuple)) and len(local_vars['input_data']) > 1:
                            # Multiple arguments
                            if isinstance(local_vars['input_data'], tuple):
                                output = func(*local_vars['input_data'])
                            else:
                                output = func(local_vars['input_data'])
                        else:
                            # Single argument
                            output = func(local_vars['input_data'])
                    else:
                        # No input data, try to call with no args or common test values
                        try:
                            output = func()
                        except TypeError:
                            # Function requires arguments, try with test value
                            output = func(1)
                else:
                    # Execute as statement
                    exec(code, global_vars, local_vars)
                    output = local_vars.get('result', None)
                
                # Check memory usage
                current_memory = process.memory_info().rss / 1024 / 1024  # MB
                memory_used = current_memory - initial_memory
                
                if memory_used > self.memory_limit_mb:
                    raise MemoryLimitExceeded(f"Memory usage: {memory_used:.2f} MB")
                
                result_queue.put(output)
                
            except Exception as e:
                exception_queue.put(e)
        
        # Start execution thread
        thread = threading.Thread(target=target)
        thread.daemon = True
        thread.start()
        
        # Wait for completion or timeout
        thread.join(timeout=self.timeout)
        
        if thread.is_alive():
            # Thread is still running, execution timed out
            raise ExecutionTimeout()
        
        # Check for exceptions
        if not exception_queue.empty():
            raise exception_queue.get()
        
        # Get result
        if not result_queue.empty():
            return result_queue.get()
        
        return None
    
    def test_function(self, func_code: str, test_cases: list) -> Dict[str, Any]:
        """Test a function against multiple test cases."""
        results = {
            'passed': 0,
            'failed': 0,
            'errors': [],
            'test_results': []
        }
        
        for i, (input_val, expected_output) in enumerate(test_cases):
            try:
                result = self.execute_safe(func_code, str(input_val))
                
                if result['success']:
                    actual_output = result['output']
                    passed = str(actual_output) == str(expected_output)
                    
                    if passed:
                        results['passed'] += 1
                    else:
                        results['failed'] += 1
                        results['errors'].append(
                            f"Test {i}: Expected {expected_output}, got {actual_output}"
                        )
                    
                    results['test_results'].append({
                        'test_id': i,
                        'input': input_val,
                        'expected': expected_output,
                        'actual': actual_output,
                        'passed': passed,
                        'execution_time': result['execution_time']
                    })
                else:
                    results['failed'] += 1
                    results['errors'].append(f"Test {i}: {result['error']}")
                    results['test_results'].append({
                        'test_id': i,
                        'input': input_val,
                        'expected': expected_output,
                        'actual': None,
                        'passed': False,
                        'error': result['error']
                    })
                    
            except Exception as e:
                results['failed'] += 1
                results['errors'].append(f"Test {i}: Exception - {str(e)}")
        
        return results
    
    def validate_program_syntax(self, program: str) -> Dict[str, Any]:
        """Validate program syntax without execution."""
        result = {
            'valid': False,
            'error': None,
            'ast_nodes': []
        }
        
        try:
            parsed_ast = ast.parse(program)
            
            # Check AST safety
            if self._validate_ast_safety(parsed_ast):
                result['valid'] = True
                result['ast_nodes'] = [type(node).__name__ for node in ast.walk(parsed_ast)]
            else:
                result['error'] = "Program contains unsafe operations"
                
        except SyntaxError as e:
            result['error'] = f"Syntax error: {str(e)}"
        except Exception as e:
            result['error'] = f"Validation error: {str(e)}"
        
        return result
    
    @contextmanager
    def temporary_limits(self, timeout: Optional[float] = None, 
                        memory_limit: Optional[int] = None):
        """Context manager for temporary execution limits."""
        old_timeout = self.timeout
        old_memory_limit = self.memory_limit_mb
        
        if timeout is not None:
            self.timeout = timeout
        if memory_limit is not None:
            self.memory_limit_mb = memory_limit
        
        try:
            yield
        finally:
            self.timeout = old_timeout
            self.memory_limit_mb = old_memory_limit
